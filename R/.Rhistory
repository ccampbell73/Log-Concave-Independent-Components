flights <- read.table('flights.csv')
head(flights)
flights <- read.table('flights.csv', header = TRUE)
head(flights)
flights
mean(flights$year)
flights <- read.csv("C:\Users\gobit\OneDrive\Documents\R\flights.csv")
flights <- read.csv("flights.csv")
head(flights)
mean(flights$year)
sd(flights$year)
flights
hist(flights$dep_delay)
head(flights)
hist(flights$dep_delay, "Histogram of Flight Departure Delay", xlab = "Departure Delay (min)", ylab = "Number Of FLights")
hist(flights$dep_delay, main = "Histogram of Flight Departure Delay", xlab = "Departure Delay (min)", ylab = "Number Of FLights")
hist(flights$dep_delay, main = "Histogram of Flight Departure Delay", xlab = "Departure Delay (min)", ylab = "Number Of FLights")
hist(flights$dep_delay, main = "Histogram of Flight Departure Delay", xlab = "Departure Delay (min)", ylab = "Number Of Flights")
max(flaights$dep_delay)
max(flights$dep_delay)
mean(flights$dep_delay)
median(flights$dep_delay)
IQR(flights$dep_delay)
sd(flights$dep_delay)
quantile(flights$dep, 0)
quantile(flights$dep, 0.5)
quantile(flights$dep_delay, 0.5)
quantile(flights$dep_delay, 0)
quantile(flights$dep_delay, 1)
quantile(flights$dep_delay, 0.25)
quantile(flights$dep_delay, 0.25)
quantile(flights$dep_delay, 0.50)
quantile(flights$dep_delay, 0.95149)
load("~/R/.RData")
head(flights)
boxplot(flights$dep_delay ~ flights$dep_day_period, main = "Distribution of Departure Delays an Different Times Of Day", xlab = "Time of Day", ylab = "Departure Delay (min)")
boxplot(flights$dep_delay ~ flights$dep_day_period, main = "Distribution of Departure Delays at Different Times Of Day", xlab = "Time of Day", ylab = "Departure Delay (min)")
make_data(100, cov)
## Terminology:
## True marginal: true marginal distribution
## Estimator marginal: marginal of the d-dim. LC-estimator
## Approx. marginal: 1D LC-estimator of data projected onto 1D subspace
## Constants
num = 100                             # number of samples
i = 1                                 # marginal of interest; 1 <= i <= dim
points <- seq(-7.5, 7.5, 0.01)        # evaluation points for 1D plots
# covariance matrix of generated data; determines dimension
covariance = matrix(c(2, -1, 0,
-1, 2, -1,
0, -1, 2), 3, 3)
## Generates and unmixes data with covariance cov, computes
## log-concave estimators for original and unmixed data
## Parameters: n = num. samples, cov = covariance matrix
make_data <- function(n, cov) {
d <<- NROW(cov)
Data <<- mvrnorm(n, numeric(d), cov)
pcomps <<- prcomp(Data)$rotation
unmixed_data <<- Data %*% pcomps
#estimator <<- mlelcd(Data)                 # comment out for speed
#unmixed_estimator <<- mlelcd(unmixed_data) # comment out for speed
projected_data_estimator <<- mlelcd(unmixed_data[,i])
variance <<- eigen(cov)$values[i]
}
## Evaluates log-concave estimator for original data at vector x
lc_estimator <- function(x) {
return(dlcd(x, estimator))
}
## Evaluates log-concave estimator for unmixed data at x
unmixed_lc_estimator <- function(x) {
return(dlcd(x, unmixed_estimator))
}
## Evaluates marginal i of unmixed LC estimator at x
estimator_marginal_i <- function(x) {
return(dmarglcd(x, unmixed_estimator, i))
}
## Evaluates approximate marginal at x
approximate_marginal_i <- function(x) {
return(dlcd(x, projected_data_estimator))
}
## Evaluates true marginal at x
true_marginal_i <- function(x) {
return(1/sqrt(2*pi*variance) * exp(-x^2/(2 * variance)))
}
## plots estimator marginal
plot_estimator_marginal <- function() {
plot(points, estimator_marginal_i(points), type = "l", col = "blue",
xlab = "", ylab = "")
}
## plots approximate marginal
plot_approximate_marginal <- function() {
plot(points, approximate_marginal_i(points), type = "l", col = "red",
xlab = "", ylab = "")
}
## plots true marginal
plot_true_marginal <- function() {
plot(points, true_marginal_i(points), type = "l", col = "green",
xlab = "", ylab = "")
}
## plots estimator and approximate marginals
plot_marginals <- function() {
plot(points, true_marginal_i(points), type = "l", col = "green",
xlab = "", ylab = "", ylim = c(0, 0.27))
lines(points, approximate_marginal_i(points), col = "red")
lines(points, estimator_marginal_i(points), col = "blue")
}
## Computes L1 distance between densities f and g
L1_distance <- function(f, g) {
pointwise_distance <- function(x) {
return(abs(f(x) - g(x)))
}
return(integrate(pointwise_distance, -Inf, Inf)$value)
}
## Computes L2 distance between densities f and g
L2_distance <- function(f, g) {
pointwise_squared_distance <- function(x) {
return((f(x) - g(x))^2)
}
return(sqrt(integrate(pointwise_squared_distance, -Inf, Inf)$value))
}
## Computes squared Hellinger distance between densities f and g
squared_Hellinger_distance <- function(f, g) {
pointwise_integrand <- function(x) {
return(0.5 * (sqrt(f(x)) - sqrt(g(x)))^2)
}
return(integrate(pointwise_integrand, -Inf, Inf)$value)
}
library(LogConcDEAD)
library(MASS, lib.loc = "C:/Program Files/R/R-4.1.1/library")
make_data()
make_data(100, covariance)
plot_approximate_marginal()
make_data(100, covariance)
plot_approximate_marginal()
make_data(10000, covariance)
make_data(1000, covariance)
plot_approximate_marginal()
plot_true_marginal()
Data <<- mvrnorm(n, numeric(d), cov)
## Terminology:
## True marginal: true marginal distribution
## Estimator marginal: marginal of the d-dim. LC-estimator
## Approx. marginal: 1D LC-estimator of data projected onto 1D subspace
## Constants
num = 100                             # number of samples
i = 1                                 # marginal of interest; 1 <= i <= dim
points <- seq(-7.5, 7.5, 0.01)        # evaluation points for 1D plots
# covariance matrix of generated data; determines dimension
covariance = matrix(c(2, -1, 0,
-1, 2, -1,
0, -1, 2), 3, 3)
## Generates and unmixes data with covariance cov, computes
## log-concave estimators for original and unmixed data
## Parameters: n = num. samples, cov = covariance matrix
make_data <- function(n, cov) {
d <<- NROW(cov)
Data <<- mvrnorm(n, numeric(d), cov)
pcomps <<- prcomp(Data)$rotation
unmixed_data <<- Data %*% pcomps
estimator <<- mlelcd(Data)                 # comment out for speed
unmixed_estimator <<- mlelcd(unmixed_data) # comment out for speed
projected_data_estimator <<- mlelcd(unmixed_data[,i])
variance <<- eigen(cov)$values[i]
}
## Evaluates log-concave estimator for original data at vector x
lc_estimator <- function(x) {
return(dlcd(x, estimator))
}
## Evaluates log-concave estimator for unmixed data at x
unmixed_lc_estimator <- function(x) {
return(dlcd(x, unmixed_estimator))
}
## Evaluates marginal i of unmixed LC estimator at x
estimator_marginal_i <- function(x) {
return(dmarglcd(x, unmixed_estimator, i))
}
## Evaluates approximate marginal at x
approximate_marginal_i <- function(x) {
return(dlcd(x, projected_data_estimator))
}
## Evaluates true marginal at x
true_marginal_i <- function(x) {
return(1/sqrt(2*pi*variance) * exp(-x^2/(2 * variance)))
}
## plots estimator marginal
plot_estimator_marginal <- function() {
plot(points, estimator_marginal_i(points), type = "l", col = "blue",
xlab = "", ylab = "")
}
## plots approximate marginal
plot_approximate_marginal <- function() {
plot(points, approximate_marginal_i(points), type = "l", col = "red",
xlab = "", ylab = "")
}
## plots true marginal
plot_true_marginal <- function() {
plot(points, true_marginal_i(points), type = "l", col = "green",
xlab = "", ylab = "")
}
## plots estimator and approximate marginals
plot_marginals <- function() {
plot(points, true_marginal_i(points), type = "l", col = "green",
xlab = "", ylab = "", ylim = c(0, 0.27))
lines(points, approximate_marginal_i(points), col = "red")
lines(points, estimator_marginal_i(points), col = "blue")
}
## Computes L1 distance between densities f and g
L1_distance <- function(f, g) {
pointwise_distance <- function(x) {
return(abs(f(x) - g(x)))
}
return(integrate(pointwise_distance, -Inf, Inf)$value)
}
## Computes L2 distance between densities f and g
L2_distance <- function(f, g) {
pointwise_squared_distance <- function(x) {
return((f(x) - g(x))^2)
}
return(sqrt(integrate(pointwise_squared_distance, -Inf, Inf)$value))
}
## Computes squared Hellinger distance between densities f and g
squared_Hellinger_distance <- function(f, g) {
pointwise_integrand <- function(x) {
return(0.5 * (sqrt(f(x)) - sqrt(g(x)))^2)
}
return(integrate(pointwise_integrand, -Inf, Inf)$value)
}
make_data(100, covariance)
plot_marginals()
plot_marginals()
library(LogConcDEAD)
library(MASS, lib.loc = "C:/Program Files/R/R-4.1.1/library")
make_data(100, covariance)
make_data(1000, covariance)
sourse('estimator-algorithm.-legacy.R')
source('estimator-algorithm.-legacy.R')
source('R/estimator-algorithm.-legacy.R')
source('R/estimator-algorithm.-legacy.R')
source(file = 'R/estimator-algorithm.-legacy.R')
source('estimator-algorithm.-legacy.R')
source(
)
source('estimator-algorithm-legacy.R')
source('R/estimator-algorithm-legacy.R')
source(`C:/Users/gobit/OneDrive/Documents/R/estimator_algorithm-legacy.R`)
source('C:/Users/gobit/OneDrive/Documents/R/estimator_algorithm-legacy.R')
knitr::opts_chunk$set(echo = TRUE)
# source("C:\Users\gobit\OneDrive\Documents\R\estimator_algorithm\R\estimator-algorithm-legacy.R")
source('R/estimator-algorithm.-legacy.R')
# source("C:\Users\gobit\OneDrive\Documents\R\estimator_algorithm\R\estimator-algorithm-legacy.R")
source('R/estimator-algorithm.-legacy.R')
source('R/estimator-algorithm.-legacy.R')
source('R/estimator-algorithm.-legacy.R')
source('R/estimator-algorithm.-legacy.R')
source('R/estimator-algorithm.-legacy.R')
source('R/estimator-algorithm.-legacy.R')
source("C:\Users\gobit\OneDrive\Documents\R\estimator_algorithm\R\estimator-algorithm-legacy.R")
source("C:/Users/gobit/OneDrive/Documents/R/estimator_algorithm-legacy.R")
